08.06.10

1) Особенности обьявления аргументов процедур
	
	1) 	procedure proc1( variable a := 12, variable b := 11 );
	
		Это допустимый синтаксис, который, впрочем, ничего особенного не 
		подразумевает. Значения переменных просто игнорируются.
		
	2) 	procedure proc2( variable begin a b c end, variable d )
		begin
			variable c; // ошибка! Переменная с уже обьявленна!
			a := 0; // первый аргумент proc2 
			b := 0; // второй аргумент proc2 
			c := 0; // локальная переменная 
			d := 0; // локальная переменная
		end
		
		// proc2 обьявляется таким образом:
		procedure proc2( variable a, variable b ); // верно
		procedure proc2( variable begin a b c end, variable d ); //верно
		procedure proc2( variable a, variable begin d s f end ); // верно
		procedure proc2( variable a, 
			variable b, variable c, variable d ); //ошибка! аргументов не 2!
		
		// Пример использования
		procedure test()
		begin
			proc2( 1, 2, 3, 4 ); // ошибка! proc2 имеет только два аргумента
			proc2( 1, 2 ); // все в порядке
		end 
	
		Тоже допустимый, но опасный синтаксис. Опасность заключается в 
		неочевидном поведении кода, сгенерированного из такого описания.
		Проблема заключается в том, что proc2 имеет всего два агрумента,
		а не четыре, как ожидалось (пояснения в коде выше). Таким образом,
		количество агрументов равно количеству variable-блоков, вне зависимости
		от количества переменных в блоке. Имена резервируются таким образом:
			- первые N имен резервируются под аргументы, где N - кол-во
			аргументов процедуры;
			- оставшиеся имена трактуются как имена локальных переменных.    
		
2)	Время переключения контекста имен

	Контекст имен переключается в момент нахождения ключевого слова procedure.
	Поэтому, следует быть осторожным с использованием имен в Event-блоке.
	
		variable a; // глобальная переменная
		
	1)	procedure proc1() when a == 1 // Используется глобальная a
		begin
		end
		
	2)	procedure proc2( variable a ) when a == 1 // Используется локальная a
		begin
		end
		
	(2) Здесь, к моменту обработки Event-блока, уже осуществленно переключение 
	на локальный контекст ( и локальное имя a уже перекрыло глобальное а) и
	возможны нередсказуемые последствия, т.к. используется стек процедуры, в 
	тот момент, когда он еще не создан.
	
3) 	Константы в Event-In

	Компилятор не проверяет тип константы в Event-In, и поэтому возможны такие
	бессмысленные конструкции
	
	1)	procedure proc1() in "1"; // не через 1 тик! 
	2) 	procedure proc2() in 12.5; // не через 12.5 тиков!
	
	В обоих случаях время будет вычесленно как реинтерпретация битов константы
	как целого. В случае (1) это будет адрес строки, 
	                 а в (2) 12.5 = 0x41480000 = 1095237632

4)  Переобьявление процедур

	Повторное обьявление процедуры без проблем проглатывается компилятором:
	
	procedure foo( variable a );
	procedure Foo( variable b ); // все в порядке
	
	Но если повторное обьявление содержит число формальных параметров, не
	совпадающее с числом оных в предыдущих обьявлениях, то компилятор "виснет"
	
	procedure foo();
	procedure Foo();
	procedure fOO( variable a );
	
	Такой код не скомпилируется.	                 